#!/usr/bin/env python

'''
  oniontracetools
  Authored by Rob Jansen, 2015
  See LICENSE for licensing information
'''

import sys, os, argparse, logging, re, datetime
from itertools import cycle
from socket import gethostname
from multiprocessing import cpu_count

from oniontracetools._version import __version__
import oniontracetools.util as util

DESC_MAIN = """
OnionTraceTools is a utility to analyze (parse) and visualize (plot) OnionTrace output.
OnionTraceTools must be run with a subcommand to specify a mode of operation.

For more information, see https://github.com/shadow/oniontrace.
"""
HELP_MAIN = """
Use 'oniontracetools <subcommand> --help' for more info
"""

DESC_ANALYZE = """
Parse results from OnionTrace log files.

This subcommand processes OnionTrace log files and stores the processed
data in json format for plotting. It was written so that the log files
need never be stored on disk decompressed, which is useful when log file
sizes reach tens of gigabytes.

The standard way to run this subcommand is to give the path to a OnionTrace
file (e.g., those produced after running `oniontrace`) or to a directory
containing such files, and the statistics parsed during the analysis
will be dumped to `oniontrace.analysis.json.xz`.
"""
HELP_ANALYZE = """
Analyze OnionTrace output
"""

DESC_VISUALIZE = """
Loads a previously parsed OnionTrace json file and plots various interesting
performance metrics to PDF files.
"""
HELP_VISUALIZE = """
Visualize OnionTrace analysis results
"""

logging.basicConfig(format='%(asctime)s %(created)f [oniontracetools] [%(levelname)s] %(message)s', level=logging.INFO, datefmt='%Y-%m-%d %H:%M:%S')

class CustomHelpFormatter(argparse.ArgumentDefaultsHelpFormatter):
    # adds the 'RawDescriptionHelpFormatter' to the ArgsDefault one
    def _fill_text(self, text, width, indent):
        return ''.join([indent + line for line in text.splitlines(True)])

def main():
    hostname = gethostname().split('.')[0]

    # argparse.RawDescriptionHelpFormatter, RawTextHelpFormatter, RawDescriptionHelpFormatter
    my_formatter_class = CustomHelpFormatter

    # construct the options
    main_parser = argparse.ArgumentParser(description=DESC_MAIN, formatter_class=my_formatter_class)

    main_parser.add_argument('-v', '--version',
        help="""Prints the version of the toolkit and exits.""",
        action="store_true", dest="do_version",
        default=False)

    sub_parser = main_parser.add_subparsers(help=HELP_MAIN)

    # analyze
    analyze_parser = sub_parser.add_parser('parse',
        description=DESC_ANALYZE,
        help=HELP_ANALYZE,
        formatter_class=my_formatter_class)
    analyze_parser.set_defaults(func=analyze, formatter_class=my_formatter_class)

    analyze_parser.add_argument(
        help="""The PATH to a OnionTrace log file, or to a directory that will be
recursively searched for OnionTrace log files; may be '-' for STDIN; each log file
may end in '.xz' to enable inline xz decompression""",
        metavar="PATH", type=type_str_path_in,
        action="store", dest="log_file_path")

    analyze_parser.add_argument('-p', '--prefix',
        help="""A directory PATH prefix where the processed data
files generated by this script will be written""",
        metavar="PATH", type=type_str_dir_path_out,
        action="store", dest="prefix",
        default=os.getcwd())

    analyze_parser.add_argument('-m', '--multiproc',
        help="""Enable multiprocessing with N worker processes, which may be '0'
to use the number of available processor cores""",
        metavar="N", type=type_nonnegative_integer,
        action="store", dest="nprocesses",
        default=1)

    analyze_parser.add_argument('-c', '--complete',
        help="""Parse and export a more complete set of statistics that is more computationally expensive to obtain""",
        action="store_true", dest="do_complete",
        default=False)

    analyze_parser.add_argument('-a', '--address',
        help="""An IP address STRING that identifies the machine where the input logfiles were produced""",
        metavar="STRING", type=type_str_ip_in,
        action="store", dest="ip_address",
        default=None)

    analyze_parser.add_argument('-n', '--nickname',
        help="""A nickname STRING that identifies the machine where the input logfiles were produced""",
        metavar="STRING", type=str,
        action="store", dest="nickname",
        default=None)

    analyze_parser.add_argument('-d', '--date-filter',
        help="""A DATE string in the form YYYY-MM-DD, all log messages that did not occur on this date will be filtered out of the analysis""",
        metavar="DATE", type=type_str_date_in,
        action="store", dest="date_filter",
        default=None)

    analyze_parser.add_argument('-e', '--expression',
        help="""Append a regex PATTERN to a custom list of strings used with
re.search to find log file names in the search path. The custom list of patterns
will override the default pattern 'oniontrace.*\.log'.""",
        metavar="PATTERN", type=str,
        action="append", dest="patterns",
        default=[])

    # visualize
    visualize_parser = sub_parser.add_parser('plot', description=DESC_VISUALIZE, help=HELP_VISUALIZE,
        formatter_class=my_formatter_class)
    visualize_parser.set_defaults(func=visualize, formatter_class=my_formatter_class)

    visualize_parser.add_argument('-d', '--data',
        help="""Append a PATH to a oniontrace.analysis.json results file, and a LABEL
        that we should use for the graph legend for this dataset""",
        metavar=("PATH", "LABEL"),
        nargs=2,
        required="True",
        action=PathStringArgsAction, dest="datasets")

    visualize_parser.add_argument('-p', '--prefix',
        help="a STRING filename prefix for graphs we generate",
        metavar="STRING", type=str,
        action="store", dest="prefix",
        default=None)

    visualize_parser.add_argument('-f', '--format',
        help="""A comma-separated LIST of color/line format strings to cycle to
                matplotlib's plot command (see matplotlib.pyplot.plot)""",
        metavar="LIST", type=str,
        action="store", dest="lineformats",
        default=util.LINEFORMATS)

    visualize_parser.add_argument('-e', '--expression',
        help="""Append a regex PATTERN to a custom list of strings used with
re.search to select which host names in the analysis results get plotted.
By default, results from all hosts in the analysis file will get plotted.""",
        metavar="PATTERN", type=str,
        action="append", dest="hostpatterns",
        default=[])

    # get args and call the command handler for the chosen mode
    args = main_parser.parse_args()
    if args.do_version:
        logging.info("OnionTraceTools version {}".format(__version__))
        return
    args.func(args)

def analyze(args):
    from oniontracetools.analysis import ParallelAnalysis, SerialAnalysis

    searchexp = args.patterns if len(args.patterns) > 0 else ["oniontrace.*\.log"]

    paths = []
    if os.path.isdir(args.log_file_path):
        # need to search
        paths = util.find_file_paths(args.log_file_path, searchexp)
    elif os.path.isfile(args.log_file_path):
        # just one file
        paths = [args.log_file_path]
    else:
        logging.warning("No valid oniontrace paths were given, nothing will be analyzed")
        return

    if len(paths) < 1:
        logging.warning("No valid oniontrace files found at path {}, nothing will be analyzed".format(args.log_file_path))
        return

    analysis = None

    if args.nprocesses == 0:
        args.nprocesses = cpu_count()

    if args.nprocesses > 1:
        analysis = ParallelAnalysis(nickname=args.nickname, ip_address=args.ip_address)
        analysis.analyze(paths, do_complete=args.do_complete, date_filter=args.date_filter,
            num_subprocs=min(args.nprocesses, len(paths)))
    else:
        analysis = SerialAnalysis(nickname=args.nickname, ip_address=args.ip_address)
        analysis.analyze(paths, do_complete=args.do_complete, date_filter=args.date_filter)

    analysis.save(output_prefix=args.prefix)

def visualize(args):
    from oniontracetools.visualization import OnionTraceVisualization
    from oniontracetools.analysis import Analysis

    lflist = args.lineformats.strip().split(",")
    lfcycle = cycle(lflist)

    oniontrace_viz = OnionTraceVisualization(args.hostpatterns)

    for (path, label) in args.datasets:
        nextformat = next(lfcycle)

        anal = Analysis.load(filename=path)
        if anal is not None:
            oniontrace_viz.add_dataset(anal, label, nextformat)

    oniontrace_viz.plot_all(args.prefix)

def type_nonnegative_integer(value):
    i = int(value)
    if i < 0: raise argparse.ArgumentTypeError("'%s' is an invalid non-negative int value" % value)
    return i

def type_supported_analysis(value):
    t = value.lower()
    if t != "all" and t != "oniontrace":
        raise argparse.ArgumentTypeError("'%s' is an invalid Analysis type" % value)
    return t

def type_str_file_path_out(value):
    s = str(value)
    if s == "-":
        return s
    p = os.path.abspath(os.path.expanduser(s))
    util.make_dir_path(os.path.dirname(p))
    return p

def type_str_dir_path_out(value):
    s = str(value)
    p = os.path.abspath(os.path.expanduser(s))
    util.make_dir_path(p)
    return p

def type_str_path_in(value):
    s = str(value)
    if s == "-":
        return s
    p = os.path.abspath(os.path.expanduser(s))
    if not os.path.exists(p):
        raise argparse.ArgumentTypeError("path '%s' does not exist" % s)
    return p

def type_str_file_path_in(value):
    s = str(value)
    if s == "-":
        return s
    p = os.path.abspath(os.path.expanduser(s))
    if not os.path.exists(p):
        raise argparse.ArgumentTypeError("path '%s' does not exist" % s)
    elif os.path.isdir(p):
        raise argparse.ArgumentTypeError("path '%s' is a directory and not a file" % s)
    return p

def type_str_ip_in(value):
    s = str(value)
    ip = re.match(r'[\d]{1,3}\.[\d]{1,3}\.[\d]{1,3}\.[\d]{1,3}', s)
    if ip is None:
        raise argparse.ArgumentTypeError("IP address '%s' is not a valid address" % s)
    return ip.group(0)

def type_str_date_in(value):
    s = str(value)
    parse_ok = False
    try:
        parts = s.split('-')
        if len(parts) == 3:
            y, m, d = int(parts[0]), int(parts[1]), int(parts[2])
            parse_ok = True
    except:
        parse_ok = False
    if not parse_ok:
        raise argparse.ArgumentTypeError("date '%s' is not in the valid YYYY-MM-DD format" % s)
    if y < datetime.MINYEAR or y > datetime.MAXYEAR:
        raise argparse.ArgumentTypeError("the year portion of date '%s' must be in the range [%d, %d]" % s, datetime.MINYEAR, datetime.MAXYEAR)
    if m < 1 or m > 12:
        raise argparse.ArgumentTypeError("the month portion of date '%s' must be in the range [1, 12]" % s)
    if d < 1 or d > 31:
        raise argparse.ArgumentTypeError("the day portion of date '%s' must be in the range [1, 31]" % s)
    return datetime.date(y, m, d)

# a custom action for passing in experimental data directories when plotting
class PathStringArgsAction(argparse.Action):
    def __call__(self, parser, namespace, values, option_string=None):
        # extract the path to our data, and the label for the legend
        p = os.path.abspath(os.path.expanduser(values[0]))
        s = values[1]
        # check the path exists
        if not os.path.exists(p): raise argparse.ArgumentError(self, "The supplied path does not exist: '{0}'".format(p))
        elif os.path.isdir(p): raise argparse.ArgumentTypeError("The supplied path '%s' is a directory and not a file" % s)
        # remove the default
        if "_didremovedefault" not in namespace:
            setattr(namespace, self.dest, [])
            setattr(namespace, "_didremovedefault", True)
        # append out new experiment path
        dest = getattr(namespace, self.dest)
        dest.append((p, s))

if __name__ == '__main__': sys.exit(main())
